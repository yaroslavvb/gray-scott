import {
    iPlane,
    iSphere,
    iReflectU4,
    abs,
    sin,
    cos,
    sqrt,
    PI,
    Group,
    splaneToString,
    objectToString,
    ParamInt,
    ParamBool,
    EventProcessor, 
    getParam,
}
from './modules.js'

const EPSILON2 = 1.e-4;
const EPSILON = 1.e-6;
const DEBUG = true;
const MYNAME = 'Group_KLM';

/*
provides generators for reflection groups generated by 3 reflections
 */
export class Group_KLM {

    constructor(arg = {}) {
        
        this.params = {
            K: getParam(arg.k, 3),
            L: getParam(arg.k, 4),
            M: getParam(arg.k, 3),
            s: getParam(arg.s, false),
            hasR: getParam(arg.hasR, false),
        };
        
        this.mParams = this.makeParams();
                
    }

    //
    // return map of current parameters (legacy API)
    //
    _getParamsMap() {

        var p = this.params;

        return {
            K: p.K,
            L: p.L,
            M: p.M,
            s: p.s,            
        };
    }

    setOptions(opt){
        if(opt.onChanged){
            this.onGroupChanged = opt.onChanged;
            this.eventProcessor = new EventProcessor();
            this.eventProcessor.addEventListener('onChanged', this.onGroupChanged);
        }                
    }
    
    
    getClassName(){
        return MYNAME;
    }
    
    //
    //  return external params 
    //
    getParams(){
        return this.mParams;
      
    }
        
    makeParams() {
        var par = this.params;
        var opc = this.onParamChanged.bind(this);

        return {
            s: ParamBool({
                obj: par,
                key: 's',
                name: '*',
                onChange: opc
            }),
            K:
            ParamInt({
                obj: par,
                key: 'K',
                min: 0,
                max: 20,
                onChange: opc,
            }),
            L: ParamInt({
                obj: par,
                key: 'L',
                min: 0,
                max: 20,
                onChange: opc,
            }),
            M: ParamInt({
                obj: par,
                key: 'M',
                min: 0,
                max: 20,
                onChange: opc,
            }),
            hasR: ParamBool({
                obj: par,
                key: 'hasR',
                name: 'has R',
                onChange: opc
            }),
        };
    } // makeParams
    //
    // called from UI when any group param was changed (legacy API)
    //
    onParamChanged(){
        if(DEBUG)console.log(this.constructor.name + '.onParamChanged()', 'eventProcessor:', this.eventProcessor);
        if(this.eventProcessor){
            this.eventProcessor.handleEvent({type:'onChanged', target: this});
        }    
    }

    /**
    set parameters from saved paramMap (legacy API)
     */
    _setParamsMap(paramsMap) {

        //this.controllers.K.setValue(paramsMap.K);
        //this.controllers.L.setValue(paramsMap.L);
        //this.controllers.M.setValue(paramsMap.M);

    }

    //
    //  return group description
    //
    getGroup() {
        var par = this.params;
        if(par.s) 
            return this.getGroup_sKLM();
        else 
            return this.getGroup_KLM();
    }
    
    //
    //
    //  return reflection group *KLM
    getGroup_sKLM() {

        var par = this.params;
        if (DEBUG)
            console.log('getGroup_sKLM: %d %d %d', par.K, par.L, par.M);

        var tri = this.getFD();

        var trans = [];
        var S0 = tri[0];
        var S1 = tri[1];
        var S2 = tri[2];
        
        var fd = [S0, S1, S2];
        if(DEBUG) console.log('%s fd: ', MYNAME, objectToString(fd));
        var trans = [[S0], [S1], [S2]];

        
        if(par.hasR) {
            // unit circle side 
            let Sr = iSphere([0,0,0, 1.]);
            fd.push(Sr);
            trans.push([Sr]);
        }

        let group = new Group({s: fd, t: trans});
        
        if(DEBUG) console.log('%s return: ', MYNAME, group);
        return group;

    }
    
    //
    //  return KLM group 
    // 
    getGroup_KLM() {

        var par = this.params;
        if (DEBUG)
            console.log('getGroup_KLM: %d %d %d', par.K, par.L, par.M);

        var tri = this.getFD();

        var trans = [];
        var S0 = tri[0];
        var S1 = tri[1];
        var S2 = tri[2];
        var S1a = iReflectU4(S0, S1);
        var S2a = iReflectU4(S0, S2);
        var fd = [S1, S2, S1a, S2a];

        if(DEBUG) console.log('%s fd: ', MYNAME, objectToString(fd));
        var trans = [[S1, S0], [S2, S0], [S0, S1], [S0, S2]];
        let group = new Group({s: fd, t: trans});

        if(par.hasR) {
            // unit circle side 
            let Sr = iSphere([0,0,0, 1.]);
            fd.push(Sr);
            trans.push([Sr]);
        }
        
        if(DEBUG) console.log('%s return: ', MYNAME, group);
        return group;

    }

    //
    //  return the fundamental domain
    //
    getFD() {

        var par = this.params;
        return this.makeTriangle(this.getAngle(par.K), this.getAngle(par.L), this.getAngle(par.M));

    }

    makeTriangle(a0, a1, a2) {

        if(DEBUG) console.log('%s.makeTriangle(%f,%f,%f)', MYNAME, a0/PI, a1/PI, a2/PI);
        
        if (abs(a0) < EPSILON) {
            return makeIdealTriangle(a0, a1, a2);
        }
        var factor = a0 + a1 + a2;

        if (DEBUG)
            console.log("Group_KLM factor: %f", factor);

        if (abs(factor - PI) < EPSILON) {
            return makeEuclideanTriangle(a0, a1, a2);
        } else if (factor > PI + EPSILON) {
            return makeSphericalTriangle(a0, a1, a2);
        } else {
            return makeHyperbolicTriangle(a0, a1, a2);
        }

    }


    //
    //  convert fraction to angle
    //
    getAngle(fraction) {

        if (fraction >= 20 || fraction < 2)
            return 0;
        else
            return Math.PI / fraction;
    }

} // class Group_KLM


//
//
//
export function makeSphericalTriangle(a0, a1, a2, triSize = 0.25) {

    if(DEBUG) console.log('%s.makeSphericalTriangle(%f,%f,%f)', MYNAME, a0/PI, a1/PI, a2/PI);

    var s = []; // sides of FD
    s[0] = iPlane([0., -1., 0., 0.]);
    s[1] = iPlane([-sin(a0), cos(a0), 0., 0.]);

    var e2 = triSize; // size of triangle

    var r = e2 * sin(a0) / (cos(a2) + cos(a1 + a0));
    var cx = r * (cos(a2) + cos(a1) * cos(a0)) / sin(a0);
    var cy = r * cos(a1);

    s[2] = iSphere([cx, cy, 0, -r]);
    return s;
    
} // makeSphericalTriangle


//
//
//
export function makeEuclideanTriangle(a0, a1, a2, triSize = 0.25) {

    var e = triSize; // size of triangle
    if(DEBUG) console.log('%s.makeEuclideanTriangle(%f,%f,%f)', MYNAME, a0/PI, a1/PI, a2/PI);

    return [
        iPlane([0., -1., 0., 0.]),
        iPlane([-sin(a0), cos(a0), 0., 0.]),
        iPlane([sin(a1), cos(a1), 0., e])
    ];

} // makeEuclideanTriangle

//
//
//
export function makeHyperbolicTriangle(a0, a1, a2) {

    if(DEBUG) console.log('%s.makeHyperbolicTriangle(%f,%f,%f)', MYNAME, a0/PI, a1/PI, a2/PI);
    var s = [];
    s[0] = iPlane([0., -1., 0., 0.]);
    s[1] = iPlane([-sin(a0), cos(a0), 0., 0.]);

    var ax = (cos(a2) + cos(a1) * cos(a0)) / sin(a0);
    var ay = cos(a1);

    var r = 1. / sqrt(ax * ax + ay * ay - 1.);

    var cx = r * ax;
    var cy = r * ay;
    s[2] = iSphere([cx, cy, 0, -r]);

    return s;
    
} // makeHyperbolicTriangle

//
//
//  special case with a0 = 0;
//   we set   splane[0] = plane ((0,-1,0),0)
//            splane[1] = sphere((-1,1,0),1)
//            splane[2] = sphere or plane which intersect s0 and s1 with given angles
//
export function makeIdealTriangle(a0, a1, a2) {

    var s = [];
    s[0] = iPlane([0., -1., 0., 0.]);
    s[1] = iSphere([-1., 1., 0., -1.]);

    //fd.s[1] = iPlane(vec3(0.,1., 0.),2.);
    var denum = (cos(a1) + cos(a2));
    if (abs(denum) < EPSILON) {
        // vertical line
        s[2] = iSphere([0., 0., 0., 1.]);
        return s;
    }

    var r3 = 2. / denum;
    var x3 = 1.;
    var y3 = r3 * cos(a1);
    //  invert in the sphere S3 = S((-1,0), 2)
    var dd = ((x3 + 1.) * (x3 + 1.) + y3 * y3 - r3 * r3);

    if (abs(dd) > EPSILON2) {
        var a = 4. / dd;
        x3 = -1. + a * (x3 + 1.);
        y3 *= a;
        r3 *= a;
        s[2] = iSphere([x3, y3, 0, -r3]);
    } else {
        // special case when inversion center (-1,0) belong to the sphere S3
        if (abs(a2) < EPSILON) {
            // case when a1 = pi/2, a2 = 0
            s[2] = iPlane([1., 0., 0, 0.]);
        } else {
            // case when a1 = pi/4, a2 = pi/2
            s[2] = iPlane([1., 1., 0, 0.]);
        }
    }
    return s;

} // makeIdealTriangle(a0, a1, a2)
